// The cmd/jujuc/server package allows a process to expose an RPC interface that
// allows client processes to delegate execution of cmd.Commands to a server
// process (with the exposed commands amenable to specialisation by context id).
package server

import (
	"bytes"
	"fmt"
	"launchpad.net/juju/go/cmd"
	"net"
	"net/rpc"
	"os"
	"path/filepath"
)

var jujucPurpose = "invoke a hosted command inside the unit agent process"
var jujucDoc = `
The jujuc command forwards invocations over RPC for execution by another
process. It expects to be called via a symlink named for the desired remote
command, and expects JUJU_AGENT_SOCKET and JUJU_CONTEXT_ID be set in its
environment.
`

// Request contains the information necessary to run a Command remotely.
type Request struct {
	ContextId string
	Dir       string
	Args      []string
}

// Response contains the return code and output generated by a Request.
type Response struct {
	Code   int
	Stdout string
	Stderr string
}

// CmdsGetter returns a list of available cmd.Commands, connected to the
// context identified by contextId.
type CmdsGetter func(contextId string) ([]cmd.Command, error)

// Jujuc wraps a set of Commands for RPC.
type Jujuc struct {
	getCmds CmdsGetter
}

// cmd returns a cmd.Command which can interpret Request arguments and run
// the appropriate subcommand against state specified by contextId.
func (j *Jujuc) cmd(contextId string) (cmd.Command, error) {
	cmds, err := j.getCmds(contextId)
	if err != nil {
		return nil, err
	}
	sc := &cmd.SuperCommand{
		Name: "(-> jujuc)", Purpose: jujucPurpose, Doc: jujucDoc,
	}
	for _, c := range cmds {
		sc.Register(c)
	}
	return sc, nil
}

// badReq returns an error indicating a bad Request.
func badReq(format string, v ...interface{}) error {
	return fmt.Errorf("bad request: "+format, v...)
}

// Main runs the Command specified by req, and fills in resp.
func (j *Jujuc) Main(req Request, resp *Response) error {
	if req.Args == nil || len(req.Args) < 1 {
		return badReq("Args is too short")
	}
	if !filepath.IsAbs(req.Dir) {
		return badReq("Dir is not absolute")
	}
	c, err := j.cmd(req.ContextId)
	if err != nil {
		return badReq("%s", err)
	}
	stdout := &bytes.Buffer{}
	stderr := &bytes.Buffer{}
	ctx := &cmd.Context{req.Dir, stdout, stderr}
	resp.Code = cmd.Main(c, ctx, req.Args)
	resp.Stdout = stdout.String()
	resp.Stderr = stderr.String()
	return nil
}

// Server wraps net.rpc.Server so as to allow Commands to be executed in one
// process on behalf of another.
type Server struct {
	socketPath string
	listener   net.Listener
	server     *rpc.Server
	Started    chan bool
	Stopped    chan bool
	closing    chan bool
	conns      chan bool
	maxConns   int
}

// NewServer starts an RPC server which runs on socketPath and which executes
// cmd.Commands in appropriate contexts (taken from getCmds).
func NewServer(getCmds CmdsGetter, socketPath string) (s *Server, err error) {
	server := rpc.NewServer()
	if err = server.Register(&Jujuc{getCmds}); err != nil {
		return
	}
	maxConns := 16
	s = &Server{
		socketPath: socketPath,
		server:     server,
		Started:    make(chan bool),
		Stopped:    make(chan bool),
		closing:    make(chan bool, 1),
		conns:      make(chan bool, maxConns),
		maxConns:   maxConns,
	}
	return
}

// Run runs the server.
func (s *Server) Run() (err error) {
	defer close(s.Stopped)
	s.listener, err = net.Listen("unix", s.socketPath)
	if err != nil {
		return
	}
	close(s.Started)
	var conn net.Conn
	for {
		conn, err = s.listener.Accept()
		if err != nil {
			break
		}
		go s.serveConn(conn)
	}

	select {
	case <-s.closing:
		err = nil
	default:
	}
	for i := 0; i < s.maxConns; i++ {
		s.conns <- false
	}
	return
}

// serveConn serves a single connection.
func (s *Server) serveConn(conn net.Conn) {
	s.conns <- true
	s.server.ServeConn(conn)
	<-s.conns
}

// Close stops a running RPC server.
func (s *Server) Close() {
	s.closing <- true
	select {
	case <-s.Started:
		s.listener.Close()
		os.Remove(s.socketPath)
	default:
	}
	<-s.Stopped
}
